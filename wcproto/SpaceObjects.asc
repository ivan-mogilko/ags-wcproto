//-----------------------------------------------------------------------------
//
// Module handles creation, update and drawing of space objects.
//
//-----------------------------------------------------------------------------

/////////////////////////////////////
// Space objects array
// TODO: maybe find a way to merge matching properties from objects and particles;
// in that case we will have to use multiple array indices per entity though.
/////////////////////////////////////
// TODO: remake Matrix and Vec4 to work with raw float arrays instead of structs?
// Find a way to pack this into the struct (as managed arrays perhaps??)
Vec4 SO_point[MAX_SPACE_OBJECTS];
float SO_size[MAX_SPACE_OBJECTS];
Vec4 SO_vel[MAX_SPACE_OBJECTS];
Vec4 SO_dir[MAX_SPACE_OBJECTS];
int SO_sprite[MAX_SPACE_OBJECTS];
int SO_count;

export SO_point, SO_vel, SO_dir;

/////////////////////////////////////
// Space particles array
/////////////////////////////////////
Vec4 SP_point[MAX_PARTICLES];
float SP_size[MAX_PARTICLES];
int SP_color[MAX_PARTICLES];
int SP_count;

/////////////////////////////////////
// Particles behavior
/////////////////////////////////////
int SpaceDust_spawnRange;
int SpaceDust_minSize;
int SpaceDust_maxSize;
int SpaceDust_greyColor1;
int SpaceDust_greyColor2;


// move point infront of ship
void respawnSpaceDust(int i) {
  float x = rnd(SpaceDust_spawnRange);
  float y = rnd(SpaceDust_spawnRange);
  float z = rnd(SpaceDust_spawnRange) + IntToFloat(SpaceDust_spawnRange * 2);
  SP_point[i].SetXYZ(
    cam_pos.x + cam_right.x * x + cam_up.x * y + cam_dir.x * z,
    cam_pos.y + cam_right.y * x + cam_up.y * y + cam_dir.y * z,
    cam_pos.z + cam_right.z * x + cam_up.y * y + cam_dir.z * z
  );
  SP_size[i] = rnd2(SpaceDust_minSize, SpaceDust_maxSize);
  int col = rndi2(SpaceDust_greyColor1, SpaceDust_greyColor2);
  SP_color[i] = Game.GetColorFromRGB(col, col, col);
}

static void SpaceObjects::RemoveAllObjects() {
  SO_count = 0;
}

static int SpaceObjects::AddObject(float x, float y, float z, float size, int sprite) {
  if (SO_count == MAX_SPACE_OBJECTS)
    return -1;
  SO_point[SO_count].SetXYZW(x, y, z, 1.0);
  SO_size[SO_count] = size;
  SO_vel[SO_count].SetXYZW(0.0, 0.0, 0.0, 0.0);
  SO_dir[SO_count].SetXYZW(0.0, 0.0, 0.0, 0.0);
  SO_sprite[SO_count] = sprite;
  SO_count++;
  return SO_count - 1;
}

static int SpaceObjects::SetupSpaceDust(int max_count, int spawn_range, int min_size, int max_size, int grey_color1, int grey_color2)
{
  max_count = maxi(max_count, MAX_PARTICLES);
  SP_count = max_count;
  SpaceDust_spawnRange = spawn_range;
  SpaceDust_minSize = min_size;
  SpaceDust_maxSize = max_size;
  SpaceDust_greyColor1 = grey_color1;
  SpaceDust_greyColor2 = grey_color2;
  
  for (int i = 0; i < max_count; i++) {
    SP_point[i].SetXYZW(rnd(spawn_range), rnd(spawn_range), rnd(spawn_range), 1.0);
    SP_size[i] = rnd2(min_size, max_size);
    int col = rndi2(SpaceDust_greyColor1, SpaceDust_greyColor2);
    SP_color[i] = Game.GetColorFromRGB(col, col, col);
  }
}

static void SpaceObjects::Init() {
}

static void SpaceObjects::DrawAll(DrawingSurface *ds) {
  ////////////////////////////////////////////////////////////////////
  // Draw space objects
  for (int i = 0; i < SO_count; i++) {
    int sprite = SO_sprite[i];
    float size = SO_size[i];
    if (sprite < 0 || size < TINY_FLOAT) continue; // skip invisible objects
    float pt[] = SO_point[i].Get();
    if (Camera3D.ToScreen(pt, size)) {
      if (screenSize <= SX * 3) {
        // TODO: cache transformed sprites when possible
        DynamicSprite *spr = DynamicSprite.CreateFromExistingSprite(SO_sprite[i], true);
        spr.Resize(screenSize * 2, screenSize * 2);
        if (screenRot > 0 && screenRot < 360) spr.Rotate(screenRot);
        screenSize = spr.Width / 2;
        ds.DrawImage(screenPos[0] - screenSize, screenPos[1] - screenSize, spr.Graphic, 0);
      }
    }
  }
  
  ////////////////////////////////////////////////////////////////////
  // Draw particles
  for (int i = 0; i < SP_count; i++) {
    float pt[] = SP_point[i].Get();
    float size = SP_size[i];
    ds.DrawingColor = SP_color[i];
    if (Camera3D.ToScreen(pt, size)) {
      if (screenSize >= 1) ds.DrawCircle(screenPos[0], screenPos[1], screenSize);
      else ds.DrawPixel(screenPos[0], screenPos[1]);
    }
    else {
      respawnSpaceDust(i);
    }
  }
}

static void SpaceObjects::UpdateAll() {
  ////////////////////////////////////////////////////////////////////
  // Update space objects
  for (int i = 0; i < SO_count; i++) {
    if (!SO_vel[i].IsZero()) {
      SO_point[i].Add(SO_vel[i].x, SO_vel[i].y, SO_vel[i].z);
    }
  }
}
